1. Even or Odd
  O(1) because we are only performing one operation

2. Are you here?
  O(n^2) because there is a nested for loop

3. Doubler
  O(n) because we are looping through the array once  

4. Naive Search
  O(n) because we are looping through the entire array

5. Creating Pairs
  O(n^2) because we have a nested for loop
  
6. Creating Fibonacci
  O(n) because the number of operations depend on the argument number

7. Efficient Search
  O(log(n)) because we are splitting our array length in half each iteration  

8. Random Element
  O(1) because it searches the array once, with a random index, then returns element

9. Is it prime?
  O(n) since we are testing each number less than our input number  

10. Counting Sheep (R)
  O(n) Dependent on the value of the argument.

11. Array Double (R)
  O(n) Dependent on the length of the array.

12. Reverse String (R)
  O(n) Dependent on the length of the string.

13. Triangular Number (R)
  O(n) Dependent on the value of parameter.

14. String Splitter (R)
  O(n) Dependent on string size for recursive looping.

15. Binary Representation (R)
  O(log(n)) because the number of recursions grows like log_2

16. Factorial (R)
  O(n) because we run n recurions

17. Fibonacci (R)
  O(2^n) because as n gets larger, it will take almost double the number of recursions as the previous n (the sum of the number of recursions for (n-1) and (n-2))

18. Anagrams (R)
  O(n!) because we will have n nested for loops with each loop having a length decreasing by 1

19. Animal Heirarchy (R)
  O(n) because we are only going through each item once, just not necessarily in order

20. Organization Chart (R)
  O(n) because we are only going through each item once, just not necessarily in order

21. Counting Sheep (I) 
  O(n) The higher the number the more -- that occur.

22. Array Doubler (I)
  O(n) Dependent on length of array given.

23. String Reverser (I) 
  O(n) Dependent on string length

24. Triangle (I)
  O(n) Dependent on size of number

25. String Seperator (I)
  O(n) Loop dependent on size of string.

26. Binary (I)
  O(Log(n)) Loop action increases by less the higher the argument number is

27. Factorial (I)
  O(n) because the size of our for loop is the magnitude of our number

28. Fibonacci (I)
  O(n) because the loop has a length of our input argument  